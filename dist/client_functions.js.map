{"version":3,"sources":["../src/client_functions.js"],"names":["getClientsURIs","checkNames","clientNames","URIs","dimensionURI","length","i","aClientName","push","convertClientsToDataPoints","aTarget","responses","response","getResponseForTarget","data","undefined","singleData","clientQueryMode","filterData","arrClientNames","filters","getClientsWithFilter","indexOf","name","datapoints","timestamp","target","clientCount","address","socket","subscriptions","version","aliasReplaced","convertClientsToJSON","newData","pushItem","item","JSON","parse","stringify","type","j","aFilter","filterType","flags","filterRegexFlags","re","RegExp","filterRegex","test","filterMessage","err","hasOwnProperty","filterFieldName","fieldVal","filterFieldValueReplaced","entry","convertClientHistoryToDataPoints","anEvent","startingTimestamp","last_execution","history","y","check","convertClientSummaryMetricsToJSON"],"mappings":"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","file":"client_functions.js","sourcesContent":["/*\n\n */\n import { getResponseForTarget, getClientsWithFilter } from './common';\n\n function getClientsURIs(checkNames, clientNames) {\n   var URIs = [];\n   var dimensionURI = '/clients';\n   // look for clientName in dimensions\n   if (clientNames.length) {\n     for (let i = 0; i < clientNames.length; i++) {\n       var aClientName = clientNames[i];\n       dimensionURI = '/clients/' + aClientName;\n       URIs.push(dimensionURI);\n     }\n   }\n   if (URIs.length === 0) {\n     URIs.push(dimensionURI);\n   }\n   URIs.push('/events');\n   URIs.push('/results');\n\n   return URIs;\n }\n\n\n/**\n * [convertClientsToDataPoints description]\n * @param  {[type]} response [description]\n * @return {[type]}          [description]\n */\nfunction convertClientsToDataPoints(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  // the result has no \"datapoints\", need to create it based on the check data\n  // when we have a checkname and an clientName, the response is different, the\n  // data is not an array, but contains the same information, recreate and push\n  if (response.data.length === undefined) {\n    var singleData = response.data;\n    response.data = [];\n    response.data.push(singleData);\n  }\n  switch (aTarget.clientQueryMode) {\n    case 'list':\n      /*jshint -W087 */\n      //debugger;\n      let filterData = [];\n      let arrClientNames = [];\n      if ((aTarget.filters !== undefined) && (aTarget.filters.length > 0)) {\n        arrClientNames = getClientsWithFilter(aTarget, response);\n        // iterate over the data and store the matching clients in the new filteredData\n        for (let i = 0; i < response.data.length; i++) {\n          // push matching client names\n          if (arrClientNames.indexOf(response.data[i].name) >= 0) {\n            filterData.push(response.data[i]);\n          }\n        }\n        // now replace data with filtered data\n        response.data = filterData;\n      }\n      for (let i = 0; i < response.data.length; i++) {\n        let data = response.data[i];\n        let datapoints = [];\n        if (data.timestamp !== undefined) {\n          datapoints[0] = [1, (data.timestamp * 1000)];\n        }\n        data.datapoints = datapoints;\n        // set the target\n        data.target = data.name;\n      }\n      break;\n    case 'count':\n      if (response.data.length > 0) {\n        let data = response.data[0];\n        let datapoints = [];\n        let clientCount = 0;\n        let arrClientNames = [];\n        if ((aTarget.filters !== undefined) && (aTarget.filters.length > 0)) {\n          arrClientNames = getClientsWithFilter(aTarget, response);\n          clientCount = arrClientNames.length;\n        }\n        else {\n          clientCount = response.data.length;\n        }\n        if (data.timestamp !== undefined) {\n          datapoints[0] = [clientCount, (data.timestamp * 1000)];\n        }\n        data.datapoints = datapoints;\n        // set the target\n        data.address = undefined;\n        data.name = undefined;\n        data.socket = undefined;\n        data.subscriptions = undefined;\n        data.version = undefined;\n        data.target = 'ClientCount';\n        if (aTarget.aliasReplaced) {\n          data.target = aTarget.aliasReplaced;\n        }\n        response.data = [data];\n      }\n      break;\n  }\n  return response;\n}\n\n/**\n * [convertClientsToJSON description]\n * @param  {[type]} response [description]\n * @param  {[type]} aTarget  [description]\n * @return {[type]}          [description]\n */\nfunction convertClientsToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  if (response.data.length === undefined) {\n    var data = response.data;\n    response.data = [];\n    response.data.push(data);\n  }\n  // start with an empty list\n  var newData = [];\n  for (var i = 0; i < response.data.length; i++) {\n    // default to adding the items, filters will set this to false as needed\n    let pushItem = true;\n    // clone it\n    let item = JSON.parse(JSON.stringify(response.data[i]));\n    // empty datapoints\n    item.datapoints = [];\n    // set the type to docs\n    item.type = 'docs';\n    //item.value = 0;\n    // if there's no address, it is a JIT client\n    var address = item.address;\n    if (item.address === 'unknown') {\n      item.address = 'JIT Client';\n    }\n    // check filters\n    if (aTarget.filters !== undefined) {\n      if (aTarget.filters.length !== undefined) {\n        for (var j = 0; j < aTarget.filters.length; j++) {\n          var aFilter = aTarget.filters[j];\n          /*jshint -W087 */\n          //debugger;\n          switch (aFilter.filterType) {\n            case 'regex':\n              // make sure the regex is valid\n              try {\n                var flags = aFilter.filterRegexFlags;\n                var re = new RegExp(aFilter.filterRegex, flags);\n                if (re.test(item.name)) {\n                  // push this one\n                  //console.log(\"matched regex\");\n                  aFilter.filterMessage = 'OK';\n                } else {\n                  pushItem = false;\n                }\n              } catch (err) {\n                aFilter.filterMessage = 'Invalid Regular Expression';\n                //console.log('Invalid Regex Detected!');\n                break;\n              }\n              break;\n            case 'field':\n              if (item.hasOwnProperty(aFilter.filterFieldName)) {\n                let fieldVal = item[aFilter.filterFieldName];\n                if (fieldVal !== aFilter.filterFieldValueReplaced) {\n                  pushItem = false;\n                }\n              } else {\n                // no field, no push\n                pushItem = false;\n              }\n              break;\n          }\n        }\n      }\n    }\n    // push into the datapoints\n    if (pushItem) {\n      //itemData.datapoints.push(itemData);\n      var entry = {\n        type: 'docs',\n        datapoints: [item]\n      };\n      newData.push(entry);\n    }\n  }\n  response.data = newData;\n  return response;\n}\n\n/**\n * [convertClientHistoryToDataPoints description]\n * @param  {[type]} response [description]\n * @return {[type]}        [description]\n */\nfunction convertClientHistoryToDataPoints(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  // the result has no \"datapoints\", need to create it based on the check data\n  // when we have a checkname and an clientName, the response is different, the\n  // data is not an array, but contains the same information, recreate and push\n  //if (response.data.length === undefined) {\n  //  var singleData = response.data;\n  //  response.data = [];\n  //  response.data.push(singleData);\n  //}\n  for (var i = 0; i < response.data.length; i++) {\n    var anEvent = response.data[i];\n    var datapoints = [];\n    var startingTimestamp = 0;\n    if (anEvent.last_execution !== undefined) {\n      startingTimestamp = anEvent.last_execution - (60 * anEvent.history.length);\n    }\n    // time needs to be in MS, we get EPOCH from Sensu\n    if (anEvent.history !== undefined) {\n      for (var y = 0; y < anEvent.history.length; y++) {\n        datapoints[y] = [anEvent.history[y], (startingTimestamp + (60 * y)) * 1000];\n      }\n    }\n    anEvent.datapoints = datapoints;\n    // set the target to be the check name\n    anEvent.target = 'unknown';\n    if (anEvent.name !== undefined) {\n      anEvent.target = anEvent.name;\n    }\n    if (anEvent.check !== undefined) {\n      anEvent.target = anEvent.check;\n    }\n  }\n  return response;\n}\n\n/**\n * Returns JSON with the following:\n *    #Checks\n *    #Checks silenced\n *    #Checks OK\n *    #Checks warning\n *    #Checks Critical\n *    #Clients\n *    #Clients silenced\n *    #Clients OK\n *    #Clients warning\n *    #Clients Critical\n * @param  {[type]} responses [description]\n * @return {[type]}           [description]\n */\nfunction convertClientSummaryMetricsToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n}\n\n\nexport {\n  convertClientsToDataPoints,\n  convertClientsToJSON,\n  convertClientHistoryToDataPoints,\n  convertClientSummaryMetricsToJSON,\n  getClientsURIs\n};\n"]}