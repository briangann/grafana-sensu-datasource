{"version":3,"sources":["../src/client_health_functions.js"],"names":["getClientHealthURIs","clientNames","URIs","length","i","aClientName","resultsURI","push","eventsURI","convertClientHealthToJSON","aTarget","responses","response","getResponseForTarget","filteredData","data","anEvent","datapoints","check","issued","undefined","timestamp","check_name","name","client","occurrences","occurrences_watermark","action","id","last_state_change","last_ok","silenced","silenced_by","executed","err","type","hideSilencedEvents","convertClientHealthMetricsToJSON"],"mappings":";;;;;;;;AAmBA;;;;;AAKA,WAASA,mBAAT,CAA6BC,WAA7B,EAA0C;AACxC,QAAIC,OAAO,EAAX;AACA;AACA,QAAID,YAAYE,MAAhB,EAAwB;AACtB,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,YAAYE,MAAhC,EAAwCC,GAAxC,EAA6C;AAC3C,YAAIC,cAAcJ,YAAYG,CAAZ,CAAlB;AACA,YAAIE,aAAa,cAAcD,WAA/B;AACAH,aAAKK,IAAL,CAAUD,UAAV;AACA,YAAIE,YAAY,aAAaH,WAA7B;AACAH,aAAKK,IAAL,CAAUC,SAAV;AACD;AACF;AACD,QAAIN,KAAKC,MAAL,KAAgB,CAApB,EAAuB;AACrBD,WAAKK,IAAL,CAAU,UAAV;AACAL,WAAKK,IAAL,CAAU,SAAV;AACD;AACD,WAAOL,IAAP;AACD;;AAED;;;;;;AA3CA;;;;;;;;;;;;;;;;;AAiDA,WAASO,yBAAT,CAAmCC,OAAnC,EAA4CC,SAA5C,EAAuD;AACrD,QAAIC,WAAWC,qBAAqBH,OAArB,EAA8BC,SAA9B,CAAf;;AAEA,QAAIG,eAAe,EAAnB;AACA;AACA,SAAK,IAAIV,IAAI,CAAb,EAAgBA,IAAIQ,SAASG,IAAT,CAAcZ,MAAlC,EAA0CC,GAA1C,EAA+C;AAC7C,UAAIY,UAAUJ,SAASG,IAAT,CAAcX,CAAd,CAAd;AACA,UAAIa,aAAa,EAAjB;AACA;AACA,UAAID,QAAQE,KAAR,CAAcC,MAAd,KAAyBC,SAA7B,EAAwC;AACtC,YAAIL,OAAO;AACTM,qBAAYL,QAAQE,KAAR,CAAcC,MAAd,GAAuB,IAD1B;AAETG,sBAAYN,QAAQE,KAAR,CAAcK,IAFjB;AAGTC,kBAAQR,QAAQQ,MAHP;AAITN,iBAAOF,QAAQE,KAJN;AAKTO,uBAAaT,QAAQS,WALZ;AAMTC,iCAAuBV,QAAQU,qBANtB;AAOTC,kBAAQX,QAAQW,MAPP;AAQTC,cAAIZ,QAAQY,EARH;AASTC,6BAAoBb,QAAQa,iBAAR,GAA4B,IATvC;AAUTC,mBAAUd,QAAQc,OAAR,GAAkB,IAVnB;AAWTC,oBAAUf,QAAQe,QAXT;AAYTC,uBAAahB,QAAQgB;AAZZ,SAAX;AAcA,YAAI;AACFjB,eAAKG,KAAL,CAAWC,MAAX,GAAoBJ,KAAKG,KAAL,CAAWC,MAAX,GAAoB,IAAxC;AACAJ,eAAKG,KAAL,CAAWe,QAAX,GAAsBlB,KAAKG,KAAL,CAAWe,QAAX,GAAsB,IAA5C;AACD,SAHD,CAGE,OAAOC,GAAP,EAAY;AACZ;AACD;AACDjB,mBAAWV,IAAX,CAAgBQ,IAAhB;AACAC,gBAAQC,UAAR,GAAqBA,UAArB;AACA,eAAOD,QAAQE,KAAf;AACA,eAAOF,QAAQQ,MAAf;AACAR,gBAAQmB,IAAR,GAAe,MAAf;AACA,YAAI,CAACnB,QAAQe,QAAb,EAAuB;AACrBjB,uBAAaP,IAAb,CAAkBS,OAAlB;AACD;AACD,YAAIA,QAAQe,QAAR,IAAoB,CAACrB,QAAQ0B,kBAAjC,EAAqD;AACnDtB,uBAAaP,IAAb,CAAkBS,OAAlB;AACD;AACF;AACF;AACDJ,aAASG,IAAT,GAAgBD,YAAhB;AACA;AACA;AACA,WAAOF,QAAP;AACD;;AAED;AACA;AACA,WAASyB,gCAAT,CAA0C3B,OAA1C,EAAmDC,SAAnD,EAA8D;AAC5D,QAAIC,WAAWC,qBAAqBH,OAArB,EAA8BC,SAA9B,CAAf;AACD,G;;AArFQE,0B,WAAAA,oB;;;qCAwFPb,mB;;2CACAS,yB;;kDACA4B,gC","file":"client_health_functions.js","sourcesContent":["/*\n  Client Health\n\n  Health is determined by taking the worst of the non-silenced results for a client\n\n  The \"unknown\" state can optionally be used as the worst state\n  Specifically:\n    /results/:client\n        status field is inspected for:\n        0 = OK\n        1 = WARNING\n        2 = CRITICAL\n        3 = UNKNOWN\n    /events/:client\n        status field is inspected\n\n */\nimport { getResponseForTarget } from './common';\n\n/**\n * [getClientHealthURIs description]\n * @param  {[type]} clientNames [description]\n * @return {[type]}             [description]\n */\nfunction getClientHealthURIs(clientNames) {\n  var URIs = [];\n  // look for clientName in dimensions\n  if (clientNames.length) {\n    for (let i = 0; i < clientNames.length; i++) {\n      var aClientName = clientNames[i];\n      var resultsURI = '/results/' + aClientName;\n      URIs.push(resultsURI);\n      var eventsURI = '/events/' + aClientName;\n      URIs.push(eventsURI);\n    }\n  }\n  if (URIs.length === 0) {\n    URIs.push('/results');\n    URIs.push('/events');\n  }\n  return URIs;\n}\n\n/**\n * [convertClientHealthToJSON description]\n * @param  {[type]} target   [description]\n * @param  {[type]} response [description]\n * @return {[type]}          [description]\n */\nfunction convertClientHealthToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  var filteredData = [];\n  //debugger;\n  for (var i = 0; i < response.data.length; i++) {\n    var anEvent = response.data[i];\n    var datapoints = [];\n    //console.log(JSON.stringify(anEvent));\n    if (anEvent.check.issued !== undefined) {\n      var data = {\n        timestamp: (anEvent.check.issued * 1000),\n        check_name: anEvent.check.name,\n        client: anEvent.client,\n        check: anEvent.check,\n        occurrences: anEvent.occurrences,\n        occurrences_watermark: anEvent.occurrences_watermark,\n        action: anEvent.action,\n        id: anEvent.id,\n        last_state_change: (anEvent.last_state_change * 1000),\n        last_ok: (anEvent.last_ok * 1000),\n        silenced: anEvent.silenced,\n        silenced_by: anEvent.silenced_by\n      };\n      try {\n        data.check.issued = data.check.issued * 1000;\n        data.check.executed = data.check.executed * 1000;\n      } catch (err) {\n        // do nothing\n      }\n      datapoints.push(data);\n      anEvent.datapoints = datapoints;\n      delete anEvent.check;\n      delete anEvent.client;\n      anEvent.type = 'docs';\n      if (!anEvent.silenced) {\n        filteredData.push(anEvent);\n      }\n      if (anEvent.silenced && !aTarget.hideSilencedEvents) {\n        filteredData.push(anEvent);\n      }\n    }\n  }\n  response.data = filteredData;\n  //var str = JSON.stringify(response, null, 2);\n  //console.log(str);\n  return response;\n}\n\n// TODO\n//  This needs to return health of individual clients\nfunction convertClientHealthMetricsToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n}\n\nexport {\n  getClientHealthURIs,\n  convertClientHealthToJSON,\n  convertClientHealthMetricsToJSON\n};\n"]}