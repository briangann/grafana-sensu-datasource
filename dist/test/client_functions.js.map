{"version":3,"sources":["../../src/client_functions.js"],"names":["getClientsURIs","checkNames","clientNames","URIs","dimensionURI","length","i","aClientName","push","convertClientsToDataPoints","aTarget","responses","response","data","undefined","singleData","clientQueryMode","filterData","arrClientNames","filters","indexOf","name","datapoints","timestamp","target","clientCount","address","socket","subscriptions","version","aliasReplaced","convertClientsToJSON","newData","pushItem","item","JSON","parse","stringify","type","j","aFilter","filterType","flags","filterRegexFlags","re","RegExp","filterRegex","test","filterMessage","err","hasOwnProperty","filterFieldName","fieldVal","filterFieldValueReplaced","entry","convertClientHistoryToDataPoints","anEvent","startingTimestamp","last_execution","history","y","check","convertClientSummaryMetricsToJSON"],"mappings":"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","file":"client_functions.js","sourcesContent":["/*\n\n */\n import { getResponseForTarget, getClientsWithFilter } from './common';\n\n function getClientsURIs(checkNames, clientNames) {\n   var URIs = [];\n   var dimensionURI = '/clients';\n   // look for clientName in dimensions\n   if (clientNames.length) {\n     for (let i = 0; i < clientNames.length; i++) {\n       var aClientName = clientNames[i];\n       dimensionURI = '/clients/' + aClientName;\n       URIs.push(dimensionURI);\n     }\n   }\n   if (URIs.length === 0) {\n     URIs.push(dimensionURI);\n   }\n   URIs.push('/events');\n   URIs.push('/results');\n\n   return URIs;\n }\n\n\n/**\n * [convertClientsToDataPoints description]\n * @param  {[type]} response [description]\n * @return {[type]}          [description]\n */\nfunction convertClientsToDataPoints(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  // the result has no \"datapoints\", need to create it based on the check data\n  // when we have a checkname and an clientName, the response is different, the\n  // data is not an array, but contains the same information, recreate and push\n  if (response.data.length === undefined) {\n    var singleData = response.data;\n    response.data = [];\n    response.data.push(singleData);\n  }\n  switch (aTarget.clientQueryMode) {\n    case 'list':\n      /*jshint -W087 */\n      //debugger;\n      let filterData = [];\n      let arrClientNames = [];\n      if ((aTarget.filters !== undefined) && (aTarget.filters.length > 0)) {\n        arrClientNames = getClientsWithFilter(aTarget, response);\n        // iterate over the data and store the matching clients in the new filteredData\n        for (let i = 0; i < response.data.length; i++) {\n          // push matching client names\n          if (arrClientNames.indexOf(response.data[i].name) >= 0) {\n            filterData.push(response.data[i]);\n          }\n        }\n        // now replace data with filtered data\n        response.data = filterData;\n      }\n      for (let i = 0; i < response.data.length; i++) {\n        let data = response.data[i];\n        let datapoints = [];\n        if (data.timestamp !== undefined) {\n          datapoints[0] = [1, (data.timestamp * 1000)];\n        }\n        data.datapoints = datapoints;\n        // set the target\n        data.target = data.name;\n      }\n      break;\n    case 'count':\n      if (response.data.length > 0) {\n        let data = response.data[0];\n        let datapoints = [];\n        let clientCount = 0;\n        let arrClientNames = [];\n        if ((aTarget.filters !== undefined) && (aTarget.filters.length > 0)) {\n          arrClientNames = getClientsWithFilter(aTarget, response);\n          clientCount = arrClientNames.length;\n        }\n        else {\n          clientCount = response.data.length;\n        }\n        if (data.timestamp !== undefined) {\n          datapoints[0] = [clientCount, (data.timestamp * 1000)];\n        }\n        data.datapoints = datapoints;\n        // set the target\n        data.address = undefined;\n        data.name = undefined;\n        data.socket = undefined;\n        data.subscriptions = undefined;\n        data.version = undefined;\n        data.target = 'ClientCount';\n        if (aTarget.aliasReplaced) {\n          data.target = aTarget.aliasReplaced;\n        }\n        response.data = [data];\n      }\n      break;\n  }\n  return response;\n}\n\n/**\n * [convertClientsToJSON description]\n * @param  {[type]} response [description]\n * @param  {[type]} aTarget  [description]\n * @return {[type]}          [description]\n */\nfunction convertClientsToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  if (response.data.length === undefined) {\n    var data = response.data;\n    response.data = [];\n    response.data.push(data);\n  }\n  // start with an empty list\n  var newData = [];\n  for (var i = 0; i < response.data.length; i++) {\n    // default to adding the items, filters will set this to false as needed\n    let pushItem = true;\n    // clone it\n    let item = JSON.parse(JSON.stringify(response.data[i]));\n    // empty datapoints\n    item.datapoints = [];\n    // set the type to docs\n    item.type = 'docs';\n    //item.value = 0;\n    // if there's no address, it is a JIT client\n    var address = item.address;\n    if (item.address === 'unknown') {\n      item.address = 'JIT Client';\n    }\n    // check filters\n    if (aTarget.filters !== undefined) {\n      if (aTarget.filters.length !== undefined) {\n        for (var j = 0; j < aTarget.filters.length; j++) {\n          var aFilter = aTarget.filters[j];\n          /*jshint -W087 */\n          //debugger;\n          switch (aFilter.filterType) {\n            case 'regex':\n              // make sure the regex is valid\n              try {\n                var flags = aFilter.filterRegexFlags;\n                var re = new RegExp(aFilter.filterRegex, flags);\n                if (re.test(item.name)) {\n                  // push this one\n                  //console.log(\"matched regex\");\n                  aFilter.filterMessage = 'OK';\n                } else {\n                  pushItem = false;\n                }\n              } catch (err) {\n                aFilter.filterMessage = 'Invalid Regular Expression';\n                //console.log('Invalid Regex Detected!');\n                break;\n              }\n              break;\n            case 'field':\n              if (item.hasOwnProperty(aFilter.filterFieldName)) {\n                let fieldVal = item[aFilter.filterFieldName];\n                if (fieldVal !== aFilter.filterFieldValueReplaced) {\n                  pushItem = false;\n                }\n              } else {\n                // no field, no push\n                pushItem = false;\n              }\n              break;\n          }\n        }\n      }\n    }\n    // push into the datapoints\n    if (pushItem) {\n      //itemData.datapoints.push(itemData);\n      var entry = {\n        type: 'docs',\n        datapoints: [item]\n      };\n      newData.push(entry);\n    }\n  }\n  response.data = newData;\n  return response;\n}\n\n/**\n * [convertClientHistoryToDataPoints description]\n * @param  {[type]} response [description]\n * @return {[type]}        [description]\n */\nfunction convertClientHistoryToDataPoints(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  // the result has no \"datapoints\", need to create it based on the check data\n  // when we have a checkname and an clientName, the response is different, the\n  // data is not an array, but contains the same information, recreate and push\n  //if (response.data.length === undefined) {\n  //  var singleData = response.data;\n  //  response.data = [];\n  //  response.data.push(singleData);\n  //}\n  for (var i = 0; i < response.data.length; i++) {\n    var anEvent = response.data[i];\n    var datapoints = [];\n    var startingTimestamp = 0;\n    if (anEvent.last_execution !== undefined) {\n      startingTimestamp = anEvent.last_execution - (60 * anEvent.history.length);\n    }\n    // time needs to be in MS, we get EPOCH from Sensu\n    if (anEvent.history !== undefined) {\n      for (var y = 0; y < anEvent.history.length; y++) {\n        datapoints[y] = [anEvent.history[y], (startingTimestamp + (60 * y)) * 1000];\n      }\n    }\n    anEvent.datapoints = datapoints;\n    // set the target to be the check name\n    anEvent.target = 'unknown';\n    if (anEvent.name !== undefined) {\n      anEvent.target = anEvent.name;\n    }\n    if (anEvent.check !== undefined) {\n      anEvent.target = anEvent.check;\n    }\n  }\n  return response;\n}\n\n/**\n * Returns JSON with the following:\n *    #Checks\n *    #Checks silenced\n *    #Checks OK\n *    #Checks warning\n *    #Checks Critical\n *    #Clients\n *    #Clients silenced\n *    #Clients OK\n *    #Clients warning\n *    #Clients Critical\n * @param  {[type]} responses [description]\n * @return {[type]}           [description]\n */\nfunction convertClientSummaryMetricsToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n}\n\n\nexport {\n  convertClientsToDataPoints,\n  convertClientsToJSON,\n  convertClientHistoryToDataPoints,\n  convertClientSummaryMetricsToJSON,\n  getClientsURIs\n};\n"]}