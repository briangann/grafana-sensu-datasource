{"version":3,"sources":["../../src/client_health_functions.js"],"names":["getClientHealthURIs","clientNames","URIs","length","i","aClientName","resultsURI","push","eventsURI","convertClientHealthToJSON","aTarget","responses","response","filteredData","data","anEvent","datapoints","check","issued","undefined","timestamp","check_name","name","client","occurrences","occurrences_watermark","action","id","last_state_change","last_ok","silenced","silenced_by","executed","err","type","hideSilencedEvents","convertClientHealthMetricsToJSON"],"mappings":";;;;;;;AAiBA;;AAEA;;;;;AAKA,SAASA,mBAAT,CAA6BC,WAA7B,EAA0C;AACxC,MAAIC,OAAO,EAAX;AACA;AACA,MAAID,YAAYE,MAAhB,EAAwB;AACtB,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,YAAYE,MAAhC,EAAwCC,GAAxC,EAA6C;AAC3C,UAAIC,cAAcJ,YAAYG,CAAZ,CAAlB;AACA,UAAIE,aAAa,cAAcD,WAA/B;AACAH,WAAKK,IAAL,CAAUD,UAAV;AACA,UAAIE,YAAY,aAAaH,WAA7B;AACAH,WAAKK,IAAL,CAAUC,SAAV;AACD;AACF;AACD,MAAIN,KAAKC,MAAL,KAAgB,CAApB,EAAuB;AACrBD,SAAKK,IAAL,CAAU,UAAV;AACAL,SAAKK,IAAL,CAAU,SAAV;AACD;AACD,SAAOL,IAAP;AACD;;AAED;;;;;;AA3CA;;;;;;;;;;;;;;;;;AAiDA,SAASO,yBAAT,CAAmCC,OAAnC,EAA4CC,SAA5C,EAAuD;AACrD,MAAIC,WAAW,kCAAqBF,OAArB,EAA8BC,SAA9B,CAAf;;AAEA,MAAIE,eAAe,EAAnB;AACA;AACA,OAAK,IAAIT,IAAI,CAAb,EAAgBA,IAAIQ,SAASE,IAAT,CAAcX,MAAlC,EAA0CC,GAA1C,EAA+C;AAC7C,QAAIW,UAAUH,SAASE,IAAT,CAAcV,CAAd,CAAd;AACA,QAAIY,aAAa,EAAjB;AACA;AACA,QAAID,QAAQE,KAAR,CAAcC,MAAd,KAAyBC,SAA7B,EAAwC;AACtC,UAAIL,OAAO;AACTM,mBAAYL,QAAQE,KAAR,CAAcC,MAAd,GAAuB,IAD1B;AAETG,oBAAYN,QAAQE,KAAR,CAAcK,IAFjB;AAGTC,gBAAQR,QAAQQ,MAHP;AAITN,eAAOF,QAAQE,KAJN;AAKTO,qBAAaT,QAAQS,WALZ;AAMTC,+BAAuBV,QAAQU,qBANtB;AAOTC,gBAAQX,QAAQW,MAPP;AAQTC,YAAIZ,QAAQY,EARH;AASTC,2BAAoBb,QAAQa,iBAAR,GAA4B,IATvC;AAUTC,iBAAUd,QAAQc,OAAR,GAAkB,IAVnB;AAWTC,kBAAUf,QAAQe,QAXT;AAYTC,qBAAahB,QAAQgB;AAZZ,OAAX;AAcA,UAAI;AACFjB,aAAKG,KAAL,CAAWC,MAAX,GAAoBJ,KAAKG,KAAL,CAAWC,MAAX,GAAoB,IAAxC;AACAJ,aAAKG,KAAL,CAAWe,QAAX,GAAsBlB,KAAKG,KAAL,CAAWe,QAAX,GAAsB,IAA5C;AACD,OAHD,CAGE,OAAOC,GAAP,EAAY;AACZ;AACD;AACDjB,iBAAWT,IAAX,CAAgBO,IAAhB;AACAC,cAAQC,UAAR,GAAqBA,UAArB;AACA,aAAOD,QAAQE,KAAf;AACA,aAAOF,QAAQQ,MAAf;AACAR,cAAQmB,IAAR,GAAe,MAAf;AACA,UAAI,CAACnB,QAAQe,QAAb,EAAuB;AACrBjB,qBAAaN,IAAb,CAAkBQ,OAAlB;AACD;AACD,UAAIA,QAAQe,QAAR,IAAoB,CAACpB,QAAQyB,kBAAjC,EAAqD;AACnDtB,qBAAaN,IAAb,CAAkBQ,OAAlB;AACD;AACF;AACF;AACDH,WAASE,IAAT,GAAgBD,YAAhB;AACA;AACA;AACA,SAAOD,QAAP;AACD;;AAED;AACA;AACA,SAASwB,gCAAT,CAA0C1B,OAA1C,EAAmDC,SAAnD,EAA8D;AAC5D,MAAIC,WAAW,kCAAqBF,OAArB,EAA8BC,SAA9B,CAAf;AACD;;QAGCX,mB,GAAAA,mB;QACAS,yB,GAAAA,yB;QACA2B,gC,GAAAA,gC","file":"client_health_functions.js","sourcesContent":["/*\n  Client Health\n\n  Health is determined by taking the worst of the non-silenced results for a client\n\n  The \"unknown\" state can optionally be used as the worst state\n  Specifically:\n    /results/:client\n        status field is inspected for:\n        0 = OK\n        1 = WARNING\n        2 = CRITICAL\n        3 = UNKNOWN\n    /events/:client\n        status field is inspected\n\n */\nimport { getResponseForTarget } from './common';\n\n/**\n * [getClientHealthURIs description]\n * @param  {[type]} clientNames [description]\n * @return {[type]}             [description]\n */\nfunction getClientHealthURIs(clientNames) {\n  var URIs = [];\n  // look for clientName in dimensions\n  if (clientNames.length) {\n    for (let i = 0; i < clientNames.length; i++) {\n      var aClientName = clientNames[i];\n      var resultsURI = '/results/' + aClientName;\n      URIs.push(resultsURI);\n      var eventsURI = '/events/' + aClientName;\n      URIs.push(eventsURI);\n    }\n  }\n  if (URIs.length === 0) {\n    URIs.push('/results');\n    URIs.push('/events');\n  }\n  return URIs;\n}\n\n/**\n * [convertClientHealthToJSON description]\n * @param  {[type]} target   [description]\n * @param  {[type]} response [description]\n * @return {[type]}          [description]\n */\nfunction convertClientHealthToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  var filteredData = [];\n  //debugger;\n  for (var i = 0; i < response.data.length; i++) {\n    var anEvent = response.data[i];\n    var datapoints = [];\n    //console.log(JSON.stringify(anEvent));\n    if (anEvent.check.issued !== undefined) {\n      var data = {\n        timestamp: (anEvent.check.issued * 1000),\n        check_name: anEvent.check.name,\n        client: anEvent.client,\n        check: anEvent.check,\n        occurrences: anEvent.occurrences,\n        occurrences_watermark: anEvent.occurrences_watermark,\n        action: anEvent.action,\n        id: anEvent.id,\n        last_state_change: (anEvent.last_state_change * 1000),\n        last_ok: (anEvent.last_ok * 1000),\n        silenced: anEvent.silenced,\n        silenced_by: anEvent.silenced_by\n      };\n      try {\n        data.check.issued = data.check.issued * 1000;\n        data.check.executed = data.check.executed * 1000;\n      } catch (err) {\n        // do nothing\n      }\n      datapoints.push(data);\n      anEvent.datapoints = datapoints;\n      delete anEvent.check;\n      delete anEvent.client;\n      anEvent.type = 'docs';\n      if (!anEvent.silenced) {\n        filteredData.push(anEvent);\n      }\n      if (anEvent.silenced && !aTarget.hideSilencedEvents) {\n        filteredData.push(anEvent);\n      }\n    }\n  }\n  response.data = filteredData;\n  //var str = JSON.stringify(response, null, 2);\n  //console.log(str);\n  return response;\n}\n\n// TODO\n//  This needs to return health of individual clients\nfunction convertClientHealthMetricsToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n}\n\nexport {\n  getClientHealthURIs,\n  convertClientHealthToJSON,\n  convertClientHealthMetricsToJSON\n};\n"]}